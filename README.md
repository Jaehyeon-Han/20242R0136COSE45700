## 개요
디자인 패턴을 배우기 위해 진행한 프로젝트이며, 프로그램은 생성, 이동, 크기 변경, 색상 변경을 지원하는 간단한 벡터 그래픽 에디터이다.
세세한 기능 구현보다 디자인 패턴의 활용과 전체 프로그램의 디자인을 중점적으로 보았다. 전체적으로는 MVC 패턴에 기반하였으나 컨트롤러가 State객체와 Command로 많이 분리된 구조이다.

## 전체 구조 클래스 다이어그램: 이벤트 흐름은 12시부터 반시계 진행
![UML Class Diagram](https://github.com/user-attachments/assets/31351028-2213-4293-ab06-876c78519992)
일부 getter와 setter, private method, 구체 클래스의 의존성은 다이어그램의 간결성을 위해 생략하였다.

## 사용한 디자인 패턴과 목적
1. State Pattern: 사용자의 마우스 이벤트를 분기 없이 처리하기 위해 사용하였다. ToolState 인터페이스를 정의하고 각 State 클래스에서 마우스 이벤트를 처리하고, 다음 상태로 전이하였다.
2: Abstract Factory Pattern: Element와 FxElement의 생성 책임을 팩토리로 위임하였다.
3. Singleton Pattern: 다수의 객체가 필요하지 않고 전역적으로 접근하면 편리한 Factory와 ElementSelector 등에 사용하였다. 단위 테스트가 어렵고, 싱글톤 객체에 대한 의존성이 증가하는 경향이 있어 더 좋은 구조를 찾아보면 좋을 것 같다.
4. Composite Pattern: 다중 선택과 조작을 위해 Element의 자식으로 Composite을 사용하였다.
5. Command Pattern: 뷰에서 모델 방향으로의 의존성을 줄이기 위해 사용하였다.
6. Observer Pattern: 모델에서 뷰로의 의존성을 줄이기 위해 사용하였다. 또한 컨트롤러 역할로 볼 수 있는 ElementSelector와 SelectedElementManager에서도 이벤트 기반 호출을 위해 사용하였다.

<!--
목표: 개방-폐쇄 원칙, 단일 책임 원칙, 의존성 역전 원칙을 지키는 방식으로 클래스 설계 및 구현
1. 개방-폐쇄 원칙: Model 클래스의 종류가 늘어났을 때 기존 코드는 수정하지 않고 새로운 클래스만 추가하면 되는가?
   - 모델 클래스의 설계 자체가 변경될 가능성을 배제할 수 없다. 특히 상속을 사용하면 더욱.
   - 따라서 서로 다른 props를 가지는 객체가 늘어날 때 base class를 어떻게 할 것인가 하는 문제가 있다.
3. 단일 책임 원칙: 각 클래스의 책임(역할)을 접속사를 사용하지 않고 설명할 수 있는가?
   - 뷰에 해당하는 클래스들은 좀 더 세부적으로 나눌 수 있을 것 같다. 예를 들면 레이아웃 클래스를 정의해서 단순히 뷰 요소를 들고 있는 역할만 하게 하거나, 각 뷰 요소의 생성책임을 팩토리로 위임할 수 있겠다.
   - 또한 DrawingPane이 ToolState를 관리하는 것이 아니라 별도의 싱글톤으로 가지는 것도 괜찮다.
5. 의존성 역전 원칙: 먼저 공통적인 행위와 관계를 인터페이스나 추상 클래스로 정의하고 구현
   - 이미 작성한 코드를 수정하는 방식으로 접근해서 할 수 없었다. 대신 동작을 추상화하도록 노력했다.
   - 지금은 간단한 프로그램이라 싱글톤을 남용하였지만 커진다면 각 요소를 인터페이스로 정의하고 의존성 주입을 통해 연결하는 방식을 사용해야 할 것이다.
   - 다음에 다시 객체지향적 프로그램을 설계한다면 더 잘 할 수 있을 것 같다.
7. 테스트 코드 작성: 주요 함수들의 단위 테스트, MVC 컴포넌트 상호작용을 Mock으로 단위 테스트 등
   - 싱글톤을 많이 사용해서 테스트가 어렵다. 다음에 프로그래밍할 때는 의존성 주입을 사용하거나 Mocking 프레임워크를 사용해야겠다.
   - 구조와 구현에 관해 시간을 많이 쓰다보니 마지막에 시간에 쫓겨 단위 테스트는 제대로 못했다.
   
# 지금까지의 과정
## abandoned branch (처음 일주일 정도)
JavaFx를 이용한 기능 구현에만 신경을 쓴 나머지 객체지향적이지도 않고 아키텍처도 불분명하여 다시 시작
  
## main branch (abandoned branch 이후-1차 리뷰 및 질의응답)
### 문제점
  - MVVM 모델을 잘못 이해: 데이터 바인딩 없는 컨트롤러를 ViewModel로 이해 → 패키지를 model/viewmodel/view로 잘못 나눔, 전반적으로 패키지에 맞지 않는 분리, 클래스 이름이 역할을 대표하지 못하거나 관용적인 의미와 배치됨
  - View의 의미 잘못 이해: 뷰 개념을 뷰 객체로 이해하여 뷰 내부에서 클래스를 나누지 않음
  - "의존성"을 잘못 이해: 함께 사용되거나, 객체 참조를 하거나, 객체에서 데이터를 꺼내오는 경우까지 의존성으로 이해

### 코드 리뷰와 질의응답을 통해 알게 된 점
  - 프로그램의 전반적 실행 흐름은 View → State → Command → Model → Controller → View
  - "의존성"의 의미: 객체 필드의 값을 원시타입으로 받는 건 의존성이 아님, 인터페이스나 중간자를 두는 것은 의존성을 통제하려는 시도
  - ProgramStatus 클래스는 객체지향 위배: 프로그램 전체 정보를 저장하는 context를 만들어서 selectedItem을 담는 것은 객체지향 위배
  - Bound box의 활용성: 대부분 도형은 bound box를 기준으로 선택 및 조작 가능하도록 구현됨
  - Handler의 명명과 역할: 잡고 늘이는 역할을 해주는 시각적 요소를 핸들러라고 하며 핸들러가 이벤트를 받도록 구현할 수 있음
  - CommandInvoker 구조: 따로 커맨드를 실행하는 Invoker 클래스를 둘 수 있음
  - SelectionManager의 사용 가능성: 따로 selection을 실행하는 SelectionManager 클래스를 둘 수 있음
  - Hit test 개념: 클릭 시에 무엇이 클릭되었는지 확인하는 과정을 hit test라고 하며 이는 각 모델 객체가 수행할 수 있어야 함
  - Model 객체 관리의 중요성: Model 객체의 list를 관리하는 것은 중요한 작업이며 별도의 클래스로 분리하는 것이 나음
    
## MVC (1차 리뷰-최종)
### 1차 리뷰를 바탕으로 바꾼 점
  - MVC 모델로의 변경: State(View) → CommandInvoker → Command → Controller → ElementManager/Selector → Controller → View
  - State 패턴을 View로 이전
  - Command 패턴 사용 시도: Command Invoker로 Controller를 Command에 주입, State가 Command 직접 생성, Resize/Translate/Create/SingleSelect까지 구현
  - 5개의 특성을 DTO로 처리 → 확장성 결여, 일부 불필요한 특성도 전달
### 방문수업에서 질문을 통해 알게된 점
  - MVC 모델에서 View가 Model 클래스에 의존성을 가져도 됨 (연관은 아님)
  - DefaultState를 두면 State의 전이를 더 간결히 표현 가능? → 개인적으로 기본값이 Create나 Select여야 한다고 봄
  - 클래스를 설계할 때 가장 중점이 되는 부분이 저장해야 하는 값을 누가 소유하는지, 이에 따라 역할이 정해짐
  - 상위 클래스 객체로 Observer에 통지할 것이 아니라 Model 객체와 View 객체를 Observer로 구체적인 타입을 알 수 있도록 연결해주면 자식에서 확장된 특성 사용 가능 (downcasting?)
### 최종 발표
  - Observer 패턴을 사용할 때는 Subject가 하나이더라도 Subject 인터페이스를 같이 정의할 것
  - State는 절대 싱글톤이 아님
  - 의존성을 줄이는 것도 좋지만 오히려 더 복잡해진다면 그냥 의존하는 것도 방법

## 특히 어려웠던 부분
   1. GUI 프로그램의 작동 방식: hit-test, 모델 객체와 뷰 객체를 분리하여 관리 등
   2. 옵저버 패턴을 사용할 때 보통 최상위 클래스로 자식 클래스 객체를 넘겨주게 되는데 받는 쪽에서는 구체적인 타입을 알아야 할 때 → 어쩔 수 없이 어디에선가 타입 체킹을 해야 함, 단 타입 체킹을 하는 부분을 한 곳에 모으고 최대한 적게하는 것이 중요
  
## 느낀점
   - 갈아엎고 다시 시작해야만 한다는 느낌은 좋은 징후가 아님, 이는 결국 처음부터 모듈화가 안 되는 모놀리틱한 설계를 했다는 것을 의미
   - 그렇게 하고 싶더라도 있는 것에서 수정하는 연습을 할 것
-->
